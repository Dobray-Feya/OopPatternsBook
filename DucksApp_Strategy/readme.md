Паттерн **Стратегия** выносит варианты поведения в семейство "алгоритмов". Эти "алгоритмы" можно независимо модифицировать. Исходный класс это не заденет.

В нашем примере есть абстрактный класс Duck и конкретные его реализации. В классе Duck определяем поведение, которое не будет меняться. Остальное нужно вынести.
Считаем, что "летание" и "крякание" может меняться. Это можно было бы вынести в интерфейс и от него наследоваться, но тут плохо, что придется этот интерфейс реализовывать для каждого вида уток. Будет много дублирования. Поэтому лучше применить композицию: т.е. включить внутрь объекта Duck объекты "летательное поведение" и "крякательное поведение". Тут еще хорошо, что можно реализовать разнообразные варианты такого поведения-"алгоритмы".

Использует следующие **принципы проектирования**:
- Инкапсулируйте то, что изменяется.
- Отдавайте предпочтение композиции перед наследованием.
- Программируйте на уровне интерфейсов, а не реализации.

Пример для последнего принципа
**программирование на уровне реализации**
```
Dog dog = new Dog();
dog.bark();
```

**программирование на уровне интерфейса/супертипа**
```
Animal animal = new Dog();
animal.MakeSound();
```

или еще лучше:
**объект конкретной реализации присваивается во время выполнения программы**
```
var animal = GetAnimal();
animal.MakeSound();
```
